/**************************************************************************************************
 * @(#)BaseRateCalculator.java
 *
 *
 *
 *************************************************************************************************/
package gov.epa.otaq.moves.master.implementation.ghg;

import gov.epa.otaq.moves.common.*;
import gov.epa.otaq.moves.master.framework.*;

import java.util.*;
import java.sql.*;

/**
 * Calculate rates using the rates-first methodology.
 *
 * @author		EPA Ed Glover
 * @author		Wesley Faler
 * @version		2015-01-01
**/
public class BaseRateCalculator extends EmissionCalculator
		implements MasterLoopContext.IContextFilter {
	/** @calculator **/

	/** Pollutants generated by the processes **/
	static final int[] pollutantIDs = { 1, 2, 3, 6, 30, 91, 118, 112, 116, 117 };
	/** Pollutants generated via integrated chaining **/
	static final int[] internalChainedPollutantIDs = { 92, 93 };
	/** processes **/
	static final int[] processIDs = { 1, 2, 9, 10, 90, 91 };
	/** polProcessIDs that are based upon distance and handled by this calculator **/
	static final int[] distancePolProcessIDs = {
		6001,6101,6201,6301,6401,6501,6601,6701,
		13001,13101,13201,13301,13401,13501,13601,13701,
		13801,13901,14001,14101,14201,14301,14401,14501,
		14601
	};

	/** The process objects used by the run, null if not used **/
	EmissionProcess[] processes = new EmissionProcess[processIDs.length];
	/** Process-Zone-RoadType-Year-Month[-Link] combinations that have been processed **/
	TreeSet<String> processedKeys = new TreeSet<String>();
	/** Loop that owns this calculator **/
	MasterLoop owningLoop = null;
	/** true when the owningLoop is only counting bundles **/
	boolean isCountingBundles = true;
	/** true when doing the first bundle **/
	boolean isFirstBundle = true;
	/** equations used to adjust SHO by road type, keyed by road type ID **/
	TreeMap<Integer,String> roadTypeActivityMultipliers = null;

	/**
	 * Constructor, including registration of potential processes and pollutants
	 * handled by this calculator.  Such registration facilitates calculator
	 * chaining.
	**/
	public BaseRateCalculator() {
		// Register
		for(int i=0;i<pollutantIDs.length;i++) {
			Pollutant pollutant = Pollutant.findByID(pollutantIDs[i]);
			if(pollutant != null) {
				for(int j=0;j<processIDs.length;j++) {
					EmissionProcess process = EmissionProcess.findByID(processIDs[j]);
					if(process != null) {
						EmissionCalculatorRegistration.register(pollutant,process,this);
					}
				}
			}
		}
		// Register distance-based pollutants
		for(int i=0;i<distancePolProcessIDs.length;i++) {
			Pollutant pollutant = Pollutant.findByID((int)(distancePolProcessIDs[i]/100));
			EmissionProcess process = EmissionProcess.findByID(distancePolProcessIDs[i] % 100);
			if(pollutant != null && process != null) {
				EmissionCalculatorRegistration.register(pollutant,process,this);
			}
		}
		// Register internally chained pollutants
		for(int i=0;i<internalChainedPollutantIDs.length;i++) {
			Pollutant pollutant = Pollutant.findByID(internalChainedPollutantIDs[i]);
			if(pollutant != null) {
				for(int j=0;j<processIDs.length;j++) {
					EmissionProcess process = EmissionProcess.findByID(processIDs[j]);
					if(process != null) {
						EmissionCalculatorRegistration.register(pollutant,process,this);
					}
				}
			}
		}
	}

	/**
	 * MasterLoopable override that performs loop registration.
	 * @param targetLoop The loop to subscribe to.
	**/
	public void subscribeToMe(MasterLoop targetLoop) {
		owningLoop = targetLoop;
		isCountingBundles = true;

		boolean didRegister = false;
		for(int j=0;j<processIDs.length;j++) {
			EmissionProcess process = EmissionProcess.findByID(processIDs[j]);
			if(process != null) {
				processes[j] = process;
				if(ExecutionRunSpec.theExecutionRunSpec.doesHavePollutantAndProcess(
						null,process.processName)) {
					targetLoop.subscribe(this, process, MasterLoopGranularity.MONTH,
							MasterLoopPriority.EMISSION_CALCULATOR);
					didRegister = true;
				}
			}
		}
	}

	/**
	 * Examine a context for suitability.  Used to override the natural execution hierarchy.
	 * @param context Context to be examined
	 * @return true if the context should be used by a MasterLoopable.
	**/
	public boolean doesProcessContext(MasterLoopContext context) {
		if(owningLoop.isCountingBundles() != isCountingBundles) {
			isCountingBundles = owningLoop.isCountingBundles();
			processedKeys.clear();
		}
		if(context.iterLocation == null || context.iterLocation.zoneRecordID < 0 || context.iterLocation.roadTypeRecordID < 0
				|| context.year < 0 || context.monthID < 0) {
			return false;
		}

		if(context.iterLocation != null && context.iterLocation.roadTypeRecordID > 0) {
			boolean isOffNetwork = context.iterLocation.roadTypeRecordID == 1;
			// Running Exhaust should not occur off network.
			if((context.iterProcess.databaseKey == 1 || context.iterProcess.databaseKey == 9 || context.iterProcess.databaseKey == 10)
					&& isOffNetwork) {
				return false;
			}
			// Several processes only occur off network.
			if(!isOffNetwork &&
					(context.iterProcess.databaseKey == 2
					|| context.iterProcess.databaseKey == 90
					|| context.iterProcess.databaseKey == 91)) {
				return false;
			}
		}

		String key = "" + context.iterProcess.databaseKey
				+ "|" + context.iterLocation.zoneRecordID + "|" + context.iterLocation.roadTypeRecordID
				+ "|" + context.year + "|" + context.monthID;
		if(context.iterProcess.databaseKey == 1 || context.iterProcess.databaseKey == 9 || context.iterProcess.databaseKey == 10) {
			key += "|" + context.iterLocation.linkRecordID;
		}
		if(processedKeys.contains(key)) {
			// doExecute was already called for the process-zone-road-year-month[-link] combination and
			// should not be run again.
			return false;
		}
		processedKeys.add(key);
		//System.out.println("Authorizing BaseRateCalculator for key: " + key + ", " + context.toBundleManifestContextForHumans());
		return true;
	}

	/**
	 * Builds SQL statements for a distributed worker to execute. This is called by
	 * EmissionCalculator.executeLoop. Implementations of this method
	 * should contain uncertainty logic when UncertaintyParameters specifies that
	 * this mode is enabled.
	 * @param context The MasterLoopContext that applies to this execution.
	 * @return The resulting sql lists as an SQLForWorker object.
	**/
	public SQLForWorker doExecute(MasterLoopContext context) {
		// Determine which pollutant(s) should be calculated
		String pollutantIDsText = "";
		String pollutantProcessIDs = "";
		boolean foundPollutant = false;
		TreeSetIgnoreCase enabledSectionNames = new TreeSetIgnoreCase();
		TreeMapIgnoreCase replacements = new TreeMapIgnoreCase();
		String sbdPolProcessID = "";

		Connection executionDatabase = null;
		try {
			executionDatabase = DatabaseConnectionManager.checkOutConnection(MOVESDatabaseType.EXECUTION);
			// Load ramp fractions. These are used to scale SHO when separating ramps.
			if(roadTypeActivityMultipliers == null) {
				roadTypeActivityMultipliers = new TreeMap<Integer,String>();
				String sql = "select roadTypeID, rampFraction"
						+ " from roadType"
						+ " where rampFraction > 0"
						+ " and roadTypeID not in (8,9)";
				SQLRunner.Query query = new SQLRunner.Query();
				try {
					query.open(executionDatabase,sql);
					while(query.rs.next()) {
						int id = query.rs.getInt(1);
						float rampFraction = query.rs.getFloat(2);
						String formula = "*(1-" + rampFraction + ")";
						roadTypeActivityMultipliers.put(new Integer(id),formula);
						if(id == 2) {
							formula = "*" + rampFraction;
							roadTypeActivityMultipliers.put(new Integer(8),formula);
						} else if(id == 4) {
							formula = "*" + rampFraction;
							roadTypeActivityMultipliers.put(new Integer(9),formula);
						}
					}
				} catch(SQLException e) {
					Logger.logSqlError(e,"Unable to query ramp fractions",sql);
				} finally {
					query.onFinally();
				}
			}
		} catch(Exception e) {
			Logger.logError(e,"Unable to get the Execution Database connection needed for running Base Rate Calculations.");
			return null;
		}

		// Check top-level pollutants
		for(int i=0;i<pollutantIDs.length;i++) {
			Pollutant pollutant = Pollutant.findByID(pollutantIDs[i]);
			if(pollutant == null) {
				continue;
			}
			PollutantProcessAssociation a = PollutantProcessAssociation.findByName(
					pollutant.pollutantName,context.iterProcess.processName);
			if(a != null) {
				if(pollutantProcessIDs.length() > 0) {
					pollutantProcessIDs += ",";
				}
				int polProcessID = a.getDatabaseKey(executionDatabase);
				pollutantProcessIDs += polProcessID;
				foundPollutant = true;
				if(pollutantIDsText.length() > 0) {
					pollutantIDsText += ",";
				}
				pollutantIDsText += "" + pollutantIDs[i];
			}
		}
		// Check distance-based pollutants
		for(int i=0;i<distancePolProcessIDs.length;i++) {
			if((distancePolProcessIDs[i] % 100) != context.iterProcess.databaseKey) {
				continue;
			}
			Pollutant pollutant = Pollutant.findByID((int)(distancePolProcessIDs[i]/100));
			if(pollutant == null) {
				continue;
			}
			PollutantProcessAssociation a = PollutantProcessAssociation.findByName(
					pollutant.pollutantName,context.iterProcess.processName);
			if(a != null) {
				if(pollutantProcessIDs.length() > 0) {
					pollutantProcessIDs += ",";
				}
				int polProcessID = a.getDatabaseKey(executionDatabase);
				pollutantProcessIDs += polProcessID;
				foundPollutant = true;
				if(pollutantIDsText.length() > 0) {
					pollutantIDsText += ",";
				}
				pollutantIDsText += "" + ((int)(distancePolProcessIDs[i]/100));
			}
		}
		// Check internally chained pollutants
		for(int i=0;i<internalChainedPollutantIDs.length;i++) {
			Pollutant pollutant = Pollutant.findByID(internalChainedPollutantIDs[i]);
			if(pollutant == null) {
				continue;
			}
			if(ExecutionRunSpec.theExecutionRunSpec.doesHavePollutantAndProcess(
					pollutant.pollutantName,context.iterProcess.processName)) {
				enabledSectionNames.add("Chain" + internalChainedPollutantIDs[i]);
			}
		}

		// Get the first Pollutant/Process for the context process that is in the
		// SourceBinDistribution and runspec.
		String sql = "SELECT sbd.polProcessID FROM SourceBinDistribution sbd"
				+ " INNER JOIN PollutantProcessAssoc ppa ON ppa.polProcessID = sbd.polProcessID"
				+ " INNER JOIN RunspecPollutantProcess rpp ON rpp.polProcessID = sbd.polProcessID"
				+ " WHERE ppa.processID = " + context.iterProcess.databaseKey + " LIMIT 1";
		SQLRunner.Query query = new SQLRunner.Query();
		try {
			query.open(executionDatabase,sql);
			if(query.rs.next()) {
				sbdPolProcessID = query.rs.getString(1);
			}
		} catch(Exception e) {
			Logger.logError(e,"Unable to get a Pollutant/Process needed for SBD aggregation.");
		} finally {
			query.onFinally();
		}
		replacements.put("##sbdPolProcessID##",sbdPolProcessID);

		if(executionDatabase != null) {
			DatabaseConnectionManager.checkInConnection(MOVESDatabaseType.EXECUTION, executionDatabase);
			executionDatabase = null;
		}

		if(!foundPollutant) {
			return null;
		}

		SQLForWorker sqlForWorker = new SQLForWorker();

		replacements.put("##pollutantIDs##",pollutantIDsText);
		replacements.put("##pollutantProcessIDs##",pollutantProcessIDs);

		OutputEmissionsBreakdownSelection outputEmissionsBreakdownSelection =
			ExecutionRunSpec.theExecutionRunSpec.getOutputEmissionsBreakdownSelection();
		if(outputEmissionsBreakdownSelection.onRoadSCC) {
			enabledSectionNames.add("SCCOutput");
		} else {
			enabledSectionNames.add("NoSCCOutput");
		}

		if(ExecutionRunSpec.theExecutionRunSpec.getModelDomain() == ModelDomain.PROJECT) {
			enabledSectionNames.add("Project");
		} else {
			enabledSectionNames.add("NotProject");
		}

		// When in rates mode and not including sourceTypeID, modelYearID, fuelTypeID, and/or regClassID
		// in the output, records need to be weighted together.
		// Don't do this in Inventory mode. Inventory mode uses sourceBinActivityFraction
		// which is already weighted.
		boolean isStartsOrExtIdleOrAPU = (context.iterProcess.databaseKey == 2 || context.iterProcess.databaseKey == 90 || context.iterProcess.databaseKey == 91);
		if(ExecutionRunSpec.theExecutionRunSpec.getModelScale() == ModelScale.MESOSCALE_LOOKUP
				&& (!ExecutionRunSpec.theExecutionRunSpec.getRunSpec().outputEmissionsBreakdownSelection.sourceUseType
					|| !ExecutionRunSpec.theExecutionRunSpec.getRunSpec().outputEmissionsBreakdownSelection.modelYear
					|| !ExecutionRunSpec.theExecutionRunSpec.getRunSpec().outputEmissionsBreakdownSelection.fuelType
					|| !ExecutionRunSpec.theExecutionRunSpec.getRunSpec().outputEmissionsBreakdownSelection.regClassID)) {
			enabledSectionNames.add("GetActivity");
			enabledSectionNames.add("AggregateSMFR");

			String activityTotalSelect = "";
			String activityTotalGroup = "";
			String activityWeightJoin = "";
			// So as to match the SQL statements, the following sections must be in this order:
			// sourceTypeID, modelYearID, fuelTypeID, regClassID
			if(ExecutionRunSpec.theExecutionRunSpec.getRunSpec().outputEmissionsBreakdownSelection.sourceUseType) {
				activityTotalSelect += ",u.sourceTypeID";
				activityTotalGroup += ",u.sourceTypeID";
				activityWeightJoin += ",sourceTypeID";
			} else {
				activityTotalSelect += ",0 as sourceTypeID";
			}
			if(ExecutionRunSpec.theExecutionRunSpec.getRunSpec().outputEmissionsBreakdownSelection.modelYear) {
				activityTotalSelect += ",u.modelYearID";
				activityTotalGroup += ",u.modelYearID";
				activityWeightJoin += ",modelYearID";
			} else {
				activityTotalSelect += ",0 as modelYearID";
			}
			if(ExecutionRunSpec.theExecutionRunSpec.getRunSpec().outputEmissionsBreakdownSelection.fuelType) {
				activityTotalSelect += ",u.fuelTypeID";
				activityTotalGroup += ",u.fuelTypeID";
				activityWeightJoin += ",fuelTypeID";
			} else {
				activityTotalSelect += ",0 as fuelTypeID";
			}
			if(ExecutionRunSpec.theExecutionRunSpec.getRunSpec().outputEmissionsBreakdownSelection.regClassID) {
				activityTotalSelect += ",u.regClassID";
				activityTotalGroup += ",u.regClassID";
				activityWeightJoin += ",regClassID";
			} else {
				activityTotalSelect += ",0 as regClassID";
			}

			replacements.put("##activityTotalSelect##",activityTotalSelect);
			replacements.put("##activityTotalGroup##",activityTotalGroup);
			replacements.put("##activityWeightJoin##",activityWeightJoin);

			if(context.iterProcess.databaseKey == 2
					|| context.iterProcess.databaseKey == 90
					|| context.iterProcess.databaseKey == 91) {
				enabledSectionNames.add("AdjustEmissionRateOnly");
			} else {
				enabledSectionNames.add("AdjustMeanBaseRateAndEmissionRate");
			}
		}

		if(context.iterProcess.databaseKey != 1) {
			enabledSectionNames.add("NotProcess1");
		}
		if(context.iterProcess.databaseKey != 2) {
			enabledSectionNames.add("NotProcess2");
		}
		if(context.iterProcess.databaseKey == 1 || context.iterProcess.databaseKey == 2) {
			enabledSectionNames.add("Process1_2");
		}
		if(context.iterProcess.databaseKey == 1 || context.iterProcess.databaseKey == 9 || context.iterProcess.databaseKey == 10) {
			enabledSectionNames.add("Process1_9_10");
		} else {
			enabledSectionNames.add("NotProcess1_9_10");
		}
		if(isFirstBundle) {
			enabledSectionNames.add("FirstBundle");
		}

		if(chainedCalculators != null && chainedCalculators.size() > 0) {
			enabledSectionNames.add("HasChainedCalculators");
		} else {
			enabledSectionNames.add("HasNoChainedCalculators");
		}

		if(ExecutionRunSpec.theExecutionRunSpec.getModelScale() == ModelScale.MESOSCALE_LOOKUP) {
			if(2 == context.iterProcess.databaseKey
					|| 90 == context.iterProcess.databaseKey
					|| 91 == context.iterProcess.databaseKey) {
				enabledSectionNames.add("ApplyActivity");
				enabledSectionNames.add("GetActivity");
			}
			if(91 == context.iterProcess.databaseKey) {
				enabledSectionNames.add("AdjustAPUEmissionRate");
			}
		} else if(ExecutionRunSpec.theExecutionRunSpec.getModelScale() == ModelScale.MACROSCALE) {
			enabledSectionNames.add("ApplyActivity");
			enabledSectionNames.add("GetActivity");
		}

		if(CompilationFlags.USE_EMISSIONRATEADJUSTMENT_FACTOR) {
			enabledSectionNames.add("EmissionRateAdjustment");
		}

		//Logger.log(LogMessageCategory.INFO,"BaseRateCalculator: " + context.toBundleManifestContextForHumans());
		boolean isOK = readAndHandleScriptedCalculations(context,replacements,
				"database/BaseRateCalculator.sql",enabledSectionNames,
				sqlForWorker);

		isFirstBundle = false;

		if(isOK) {
			return sqlForWorker;
		} else {
			return null;
		}
	}
}
